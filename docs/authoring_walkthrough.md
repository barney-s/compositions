# Composition authoring walkthrough

This document shows how to write compositions for any use case. We use the example of writing the [CloudSQL composition](gcp_cloudsql_scenario.md) to explore more features of compositions. 

## Concepts

The concepts explored in this chapter are:

* Steps to write a composition  
* Parts of a Composition  
  * Stages  
  * Expander types  
  * Parametrizing resources with Jinja2 templates  
* Facade  
* Context  
* Getters

## Authoring the CloudSQL composition

In this section you will be guided through the steps to author your own compositions. Compositions can be very simple, or may define many resources and include templating logic that uses the end user inputs. 

By the end of these steps, you will have the `CloudSQL` Facade CRD that can be used by your app teams to create Cloud SQL instances with encryption and replication across regions.  Your app teams can do this without being required to understand Kubernetes or the GCP service APIs.  Moreover, the app teams automatically follow your security policy and best-practices, because you have set this up in the composition.

The key steps in authoring compositions are:

1. **Planning** \- Determining what functionality you want to offer your app team,  and identifying the cloud resources required to build it.  
2. **Writing the managed resources** \- Write the raw (non-templated) KCC/ACK/ASO resources for the cloud resources.  
3. **Writing the developer interface** \- Deciding what parameters you want to expose to end users and creating a Facade CRD for the parameters.  
4. **Writing the Composition** \- Parameterize the KCC/ACK/ASO  resources.

We will walk through these steps using the Cloud SQL composition from Scenario 2\. At the end, you should be ready to create a Composition specific to your organization. 

### Step 1: Planning

A platform admin creates Compositions based on their org’s requirements.  These requirements could be based on cloud resource consumption patterns, policies concerning security, reliability, data availability etc.  Writing a composition starts with understanding a repeatable use case. 

In this example we create a way for developers to create highly-available Cloud SQL instances through a self-service API. We first identify the cloud resources required. For this example, the cloud resources required are: 

* Cloud SQL Database instances: SQLInstance   
* GCP services to be enabled: Service, ServiceIdentity  
* Enabling encryption: KMSKeyRing, KMSCryptoKey  
* Policies to control access: IAMPolicyMember

### Step 2: Writing the managed resources {#step-2:-writing-the-managed-resources}

Define your cloud resources using  [KCC](https://cloud.google.com/config-connector/docs/reference/overview) (or ACK / ASO, if you are using AWS or Azure). These KCC resources will be generated by the Composition.

For example, the ServiceIdentity resource would be written as follows: 

```yaml
apiVersion: serviceusage.cnrm.cloud.google.com/v1beta1
kind: ServiceIdentity
metadata:
    name: sqladmin.googleapis.com
    namespace: config-control
spec:
    projectRef:
      external: myprojectid
```

Similarly a key ring can be defined like this:

```yaml
apiVersion: kms.cnrm.cloud.google.com/v1beta1
kind: KMSKeyRing
metadata:
   name: kmscryptokeyring-us-central1
   namespace: config-control
spec:
   location: us-central1
```

Write out the KCC manifest for all resources that will be managed in your composition. The complete list of KCC resources for the CloudSQL example is [available here](https://github.com/cloud-native-compositions/compositions/blob/main/samples/CloudSQL/composition/hasql.yaml#L94).

### Step 3: Write the Facade API

The KCC resources identified to be part of a composition would have slightly varying parameters for each team’s usage. Identify the parameters that vary across teams and list them out. Other parameterization like conditional setting of values, enumeration over ranges etc should also be identified.

In the CloudSQL example, the parameters that are expected to be different for each team are:

* Namespace (project) for the KCC objects  
* Base name of the CloudSQL instances

You can also parameterize for team specific concerns:

* Regions in which to create the CloudSQL replicas

These parameters will become the inputs in the Facade CRD. You will write Expander templates to use these inputs.   
By default, the output  resources’ namespace is set to the namespace of the `idp.mycompany.com/CloudSQL` input resource. If you want to override the namespace of the output resources, set the `.spec.namespaceMode: explicit` in the composition.

**Generating the** `idp.mycompany.com/CloudSQL` **CRD**   
The Facade CRDs can be generated from Go code using [kubebuilder](https://book.kubebuilder.io/cronjob-tutorial/new-api). Install kubebuilder by following the [instructions here](https://book.kubebuilder.io/quick-start).

1. Create project scaffolding

```shell
mkdir -p ~/projects/idp
cd ~/projects/idp
kubebuilder init --domain mycompany.com --repo mycompany.com/idp
```

2. Create scaffolding for the `CloudSQL` CRD

```shell
kubebuilder create api --group idp --version v1alpha1 --kind CloudSQL --controller=false --resource
```

3. Edit the golang file to add the fields

```shell
# choose editor of your choice
vim api/v1alpha1/cloudsql_types.go

## Edit the Spec struct to include regions and name. 
## The CloudSQLSpec should look like this
# type CloudSQLSpec struct {
#	Regions []string `json:"regions"`
#	Name    string   `json:"name"`
#}
```

4. Generate the CRD file

```shell
make manifests
# The CRD should be generated in this file:
# config/crd/bases/idp.mycompany.com_cloudsqls.yaml
```

5. Apply the generated CRD to your cluster

```shell
kubectl apply -f config/crd/bases/idp.mycompany.com_cloudsqls.yaml
```

### Step 4: Authoring the Composition

#### Add the KCC objects

Create the `sqlha` Composition by using KCC objects from [step 2](#step-2:-writing-the-managed-resources). We set the `.spec.inputAPIGroup` to `cloudsqls.idp.mycompany.com` to illustrate that this is how we define the link between the Composition and the Facade. 

```yaml
apiVersion: composition.google.com/v1alpha1
kind: Composition
metadata:
 name: sqlha
spec:
 # we have a plan to replace  inputAPIGroup field with apiVersion, Kind fields.
 # inputAPI:
 #   apiVersion: idp.mycompany.com/v1alpha1
 #   kind: CloudSQL
 inputAPIGroup: cloudsqls.idp.mycompany.com
 expanders:
 - type: jinja2  # inbuilt jinja2 expander
   name: server
   template: |
     ... # copy the KCC objects here .
```

#### Split into stages

You can split the KCC objects across multiple expander-stages. Some reasons to do so:

1. Control the sequence in which KCC objects are created  
2. Use the output of a KCC object as a parameter in a subsequent stage  
3. Group relevant KCC objects in stages for readability

In the [CloudSQL example](https://github.com/cloud-native-compositions/compositions/blob/main/samples/CloudSQL/composition/hasql.yaml), we split it into 4 expander stages:

* First stage: Create the *Service* resources to enable GCP APIs for later stages  
* Second stage: Create the *ServiceIdentity* as we will need the generated email address in the IAM resource.  
* Third stage: A getter stage to extract the email address from the ServiceIdentity object  
* Fourth stage: Creates the IAM resources, KMSKeyRings, KMSCryptoKeys, IAMPolicyMembers, and SQLInstances for each region.

#### Parameterize the KCC objects

**Jinja2**  
If you are familiar with [Jinja](https://jinja.palletsprojects.com/en/3.1.x/)  you can use it to write the templates for your composition. KCC compositions is bundled with jinja2 as an expander out-of-the-box.   
[Jinja supports](https://jinja.palletsprojects.com/en/3.1.x/templates/):

* [Variable substitution](https://jinja.palletsprojects.com/en/3.1.x/templates/#variables)  
* [Defaulting](https://jinja.palletsprojects.com/en/3.1.x/templates/#jinja-filters.default)  
* [Conditional sections](https://jinja.palletsprojects.com/en/3.1.x/templates/#if)  
* [For loops](https://jinja.palletsprojects.com/en/3.1.x/templates/#for)  
* [Filters](https://jinja.palletsprojects.com/en/3.1.x/templates/#list-of-builtin-filters)

You are able to use any of the Jinja features within your composition. For example, the composition below uses the looping and conditionals when defining the SQLInstance resource. 

**The Context API**  
Every namespace can have the optional `Context` object, that is available as `context` in the expander evaluation. Currently it has a `.spec.project` that points to the GCP project. This lets the expanders understand which project they are operating within, so you don’t need to specify it for every resource definition. 

Here is an example of how to write the context for your composition. The context object is created per namespace. This example uses the namespace `clearing-service` as well as the GCP project `clearing-service`.

```yaml
apiVersion: composition.google.com/v1alpha1
kind: Context
metadata:
  name: context
  namespace: clearing-service
spec:
  project: clearing-service
```

In the `Config Controller` instance, the default `config-control` namespace comes with a pre-populated Context object. If you want to use compositions in additional namespaces you will need to create a new context object in those additional namespaces. If you want to change the Google Cloud project that the composition uses, you will need to change the project in the existing context object. 

**Available variables**  
All expanders provide access to these some common objects: Facade, context and values.  
The jinja expander exposes these as templating variables:

1. `cloudsqls`, the Facade API. The jinja template schema values can be used in the template as:  
   1. *`cloudsqls.spec.name`*   
   2. *`cloudsqls.spec.regions`*  
2. `context` (per namespace) contains the commonly used values such as *`context.spec.project`*. We define the context for this example below.   
3. `values` contain the results of `Getter` stages. A `Getter` reads field values from a kubernetes object. 

**Example parameterized KCC resource**  
Here is the Jinja templating for the *ServiceIdentity* resource from Step 2:

```yaml
 - type: jinja2
    name: block2
    template: |
      apiVersion: serviceusage.cnrm.cloud.google.com/v1beta1
      kind: ServiceIdentity
      metadata:
        name: sqladmin.googleapis.com
        # {{ }} indicates jinja templating tokens
        # here we are injecting the namespace from the facade
        namespace: {{ cloudsqls.metadata.namespace }}
      spec:
        projectRef:
          # here we are injecting the project from context
          external: {{ context.spec.project }}

```

#### Understanding Getters

Getters allow you to get values from objects in the cluster. These objects may be created as part of the composition, or may be pre-existing objects. Values from these objects can be used to populate fields in the composition. 

Some example values: 

1. Master IP address/URI of a cluster  
2. Email of a GCP Service Identity 

Use a `Getter` to extract any such dynamic values.

Here is an example `GetterConfiguration` that extracts the Service identity email:

```yaml
apiVersion: composition.google.com/v1alpha1
kind: GetterConfiguration
metadata:
  name: sql-siemail # used in composition
  namespace: default
spec:
  valuesFrom:
  - name: identity # extracted values are referred as values.identity
    resourceRef:   # use GVK Namespace Name to locate the object
      group: serviceusage.cnrm.cloud.google.com
      version: v1beta1
      kind: ServiceIdentity
      resource: serviceidentities
      nameSuffix: "-sqladmin" # becomes {{ facade.metadata.name }}-sqladmin
    fieldRef:
    - path: ".status.email"  # grab the .status.email and project it as .email
      as: email # used in composition, field is reffered as values.identity.email
```

The `GetterConfiguration` is used in the Composition like this:

```yaml
apiVersion: composition.google.com/v1alpha1
kind: Composition
metadata:
 name: sqlha
spec:
 inputAPIGroup: cloudsqls.facade.compositions.google.com
 expanders:
  ...
  # STAGE 2 creates the ServiceIdentity object
  - type: jinja2 # stage 2
    name: create-serviceidentity
    template: |
      apiVersion: serviceusage.cnrm.cloud.google.com/v1beta1
      kind: ServiceIdentity
      metadata:
        name: {{ cloudsqls.spec.name }}-sqladmin #nameSuffix getter config 
        namespace: {{ cloudsqls.metadata.namespace }}
      spec:
        projectRef:
          external: {{ context.spec.project }}
  # Getter in STAGE 3 waits for the .status.email in ServiceIdentity
  - type: getter # stage 3, waits for value from service-identity
    version: v0.0.1
    name: get-serviceidentity
    template: ""
    configref:
      name: sql-siemail # reference to getter configuration
      namespace: default
  # STAGE 4 uses the extracted email value
  - type: jinja2 # stage 4, uses values extracted by prev stage
    name: create-sqlinstances
    version: v0.0.1
    template: |
      ...
      apiVersion: iam.cnrm.cloud.google.com/v1beta1
      kind: IAMPolicyMember
      metadata:
        name: sql-kms-{{ region }}-policybinding
        namespace: {{ cloudsqls.metadata.namespace }}
      spec:
        member: serviceAccount:{{ values.identity.email }} # getter value
        role: roles/cloudkms.cryptoKeyEncrypterDecrypter
        resourceRef:
      ...
```

The `ServiceIdentity’s .status.email` reconciled in state 2 is extracted by the Getter in stage 3 and used by the objects in stage 4\. 

### Step 5: Applying the Composition

Now that you have written your composition and facade you can apply them to the cluster, using the example available [repo](https://github.com/cloud-native-compositions/compositions).

```shell
# if not cloned already
git clone https://github.com/cloud-native-compositions/compositions.git

cd samples/CloudSQL
kubectl apply -f composition/hasql.yaml
```

Check if the composition is installed successfully. You should see something like this. Any jinja template parsing errors would be surfaced in the status at this point as part of validation.

```shell
❯ kubectl get composition sqlha -o json | jq .status
{
  "stages": {
    "block2": {
      "reason": "ValidationPassed",
      "validationStatus": "success"
    },
    "block3": {
      "reason": "ValidationPassed",
      "validationStatus": "success"
    },
    "enable-services": {
      "reason": "ValidationPassed",
      "validationStatus": "success"
    },
    "get-serviceidentity": {
      "reason": "ValidationPassed",
      "validationStatus": "success"
    }
  }
}
```

### Step 6: Using the Composition

Now that the Composition has been applied, a user can create an instance of the composition.   
The example below shows the CloudSQL Facade defined in Step 3 to create CloudSQL instances in us-east1 and us-central1, with the us-east1 being the primary. 

```shell
kubectl apply -f - <<EOF
apiVersion: idp.mycompany.com/v1alpha1
kind: CloudSQL
metadata:
  name: collateral
  namespace: config-control
spec:
  regions:
  - us-east1
  - us-central1
  name: collateral-db
EOF
```

### Step 7: Verify

Verify the KCC resources are created and reconciled successfully. Look at the `READY` and `STATUS` columns of the command output. They should be `True` and `UpToDate` respectively.

```shell
NAMESPACE=config-control
# KCC objects in config-control namespace
kubectl get serviceidentity -n ${NAMESPACE?}
kubectl get sqlinstances.sql.cnrm.cloud.google.com -n ${NAMESPACE?}
kubectl get kmskeyring -n ${NAMESPACE?}
kubectl get kmscryptokey -n ${NAMESPACE?}
kubectl get iampolicymember -n ${NAMESPACE?}
kubectl get services.serviceusage.cnrm.cloud.google.com -n ${NAMESPACE?}

# A helper script includes the above commands:
./get_cloudsql.sh ${NAMESPACE?}
```

Sample output:

```shell
❯ ./get_cloudsql.sh ${NAMESPACE?}

ServiceIdentity ----------------------------------------
NAME                      AGE   READY   STATUS     STATUS AGE
sqladmin.googleapis.com   19m   True    UpToDate   19m

SqlInstance --------------------------------------------
NAME                            AGE   READY   STATUS     STATUS AGE
myteam-db-main                  19m   True    UpToDate   15m
myteam-db-replica-us-central1   19m   True    UpToDate   6m57s

KMSKeyRings --------------------------------------------
NAME                           AGE   READY   STATUS     STATUS AGE
kmscryptokeyring-us-central1   19m   True    UpToDate   19m
kmscryptokeyring-us-east1      19m   True    UpToDate   19m

KMSCryptoKeys ------------------------------------------
NAME                           AGE   READY   STATUS     STATUS AGE
kmscryptokey-enc-us-central1   19m   True    UpToDate   19m
kmscryptokey-enc-us-east1      19m   True    UpToDate   19m

IAMPolicyMember ----------------------------------------
NAME                                AGE   READY   STATUS     STATUS AGE
sql-kms-us-central1-policybinding   19m   True    UpToDate   19m
sql-kms-us-east1-policybinding      19m   True    UpToDate   19m

ServiceUsage -------------------------------------------
NAME                          AGE   READY   STATUS     STATUS AGE
cloudkms.googleapis.com       19m   True    UpToDate   19m
iam.googleapis.com            19m   True    UpToDate   19m
serviceusage.googleapis.com   19m   True    UpToDate   19m
sqladmin.googleapis.com       19m   True    UpToDate   19m

```

Also inspect the `Plan` object created for the `cloudsqls` instance. The `Plan` object is an intermediate API that is used to track expanded resources and their status. This is useful to debug if something goes amiss:

```shell
# Plan object corresponding to the appteam instance
#                              >>>facadecrd-cr.name<<<
kubectl get plan -n config-control cloudsqls-myteam

apiVersion: composition.google.com/v1alpha1
kind: Plan
...
  name: cloudsqls-myteam
  namespace: config-control
spec:
  stages:
    ...
    enable-services:
      manifest: |2+
        ---
        apiVersion: serviceusage.cnrm.cloud.google.com/v1beta1
        kind: Service
        metadata:
          annotations:
            cnrm.cloud.google.com/deletion-policy: "abandon"
            cnrm.cloud.google.com/disable-dependent-services: "false"
          name: cloudkms.googleapis.com
          namespace: config-control
        spec:
          resourceID: cloudkms.googleapis.com
        ---
        ...
    get-serviceidentity:
      values: '{"identity":{"email":"service-551315786471@gcp-sa-cloud-sql.iam.gserviceaccount.com"}}'
status:
  compositionGeneration: 1
  compositionUID: 88c55c16-590b-4324-aae5-cb3cd19835fb
  conditions:
  - lastTransitionTime: "2024-07-18T11:54:53Z"
    message: 'Evaluated and Applied stages: enable-services, block2, block3'
    reason: ProcessedAllStages
    status: "True"
    type: Ready
  generation: 5
  inputGeneration: 1
  stages:
    block3:
      appliedCount: 8
      lastApplied:
      - group: kms.cnrm.cloud.google.com
        health: Healthy
        kind: KMSKeyRing
        name: kmscryptokeyring-us-east1
        namespace: config-control
        status: Resource is current
        version: v1beta1
      - group: kms.cnrm.cloud.google.com
        health: Healthy
        kind: KMSCryptoKey
        name: kmscryptokey-enc-us-east1
        namespace: config-control
        status: Resource is current
        version: v1beta1
       ...
      resourceCount: 8
    enable-services:
      appliedCount: 4
      lastApplied:
      - group: serviceusage.cnrm.cloud.google.com
        health: Healthy
        kind: Service
        name: cloudkms.googleapis.com
        namespace: config-control
        status: Resource is current
        version: v1beta1
        ...
      resourceCount: 4
```

The Plan’s spec records the expanded objects for each stage. The status details the applied object count as well as the health of the applied KCC objects.

## Questions

1. How do you feel about using Getters to propagate the ServiceIdentity object’s `.status.email` to `values.identity.email` ? Would you instead prefer the ability to get all the previously applied objects and refer to them using something like this `objects.serviceidentity.sqladmin.googleapis.com.<name>.status.email ?`